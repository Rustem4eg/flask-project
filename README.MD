# Flask. Урок 1. Создание первой программы
## 1. Установка Flask

Перед началом работы убедитесь, что у вас установлен Python версии 3.7 или выше. Затем выполните установку Flask с помощью команды:
```
pip install flask
```
Проверьте успешность установки, выполнив:
```
python -m flask --version
```
## 2. Создание первой программы "Hello, Flask!"
Создайте новый файл с именем **app.py** в рабочей директории и добавьте следующий код:
```
from flask import Flask

# Создаем объект приложения Flask
app = Flask(__name__)

# Определяем маршрут и привязываем его к функции
@app.route('/')
def hello():
    return "Hello, Flask!"

# Запуск приложения
if __name__ == "__main__":
    app.run(debug=True)
```
**Объяснение кода:**
1. **Создание экземпляра приложения:**
```
app = Flask(__name__)
```
Здесь создается экземпляр приложения Flask. Аргумент __name__ используется для того, чтобы Flask мог правильно определять ресурсы и маршруты в вашем приложении.
2. **Маршрут и функция:**
```
@app.route('/')
def hello():
    return "Hello, Flask!"
```
* Декоратор *@app.route('/')* связывает определенный маршрут (в данном случае /, корневой URL) с функцией *hello()*.

Когда пользователь переходит по адресу http://127.0.0.1:5000/, функция *hello()* срабатывает и возвращает строку "Hello, Flask!".

3. **Запуск сервера:**
```
if __name__ == "__main__":
    app.run(debug=True)
```
* Проверка if __name__ == "__main__" гарантирует, что сервер запустится только в том случае, если файл выполняется как основной модуль.

* Метод `run()` запускает сервер разработки Flask. Параметр `debug=True` включает режим отладки, который автоматически перезагружает сервер при изменениях в коде и предоставляет удобные сообщения об ошибках.
**Примечания:**

* При запуске сервера может появиться следующая ошибка:
```
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-6: ordinal not in range(128)
```
Такая ошибка возникает, если имя компьютера написано кириллицей. В этом случае переименуйте имя компьютера, чтобы оно содержало только латинские символы, цифры и дефисы.

* Flask запускает сервер по адресу http://127.0.0.1:5000/. Этот адрес ещё называется `localhost`. Перейдя по этому адресу в браузере, вы увидите результат работы функции `hello()`.

**Как это работает**:
1. Когда вы запускаете файл app.py, метод run() создает сервер.
2. Сервер обрабатывает запросы, поступающие на указанный адрес (127.0.0.1:5000).
3. Браузер отправляет HTTP-запрос на сервер при переходе по адресу http://127.0.0.1:5000/.
4. Сервер вызывает функцию hello(), связанную с маршрутом /, и отправляет её результат ("Hello, Flask!") обратно браузеру.
5. Браузер отображает полученный результат на странице.  
Функции, которые обрабатывают запросы и возвращают ответы, называются вьюхами (от англ. view — представление). Подробнее про них поговорим в следующем уроке. 

## 3. Запуск локального сервера
![Alt text](/app/static/images/1.png)

Чтобы запустить сервер, выполните команду или нажмите Run:
```
python app.py
```
Вы увидите сообщение в консоли, похожее на это:
```
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 123-456-789
```
Откройте браузер и перейдите по адресу http://127.0.0.1:5000/. Или просто нажмите на него в терминале и станица в браузере откроется автоматически. Вы увидите сообщение:
```
Hello, Flask!
```
Поздравляю, ваше первое приложение на Flask запущено!

Для завершения работы сервера нажмите CTRL+C в терминале или кнопку Stop

## Задание
Создайте ваше первое приложение Flask:
Следуя инструкциям урока, напишите код, который возвращает сообщение "Hello, Flask!".
Запустите локальный сервер и убедитесь, что приложение работает корректно.
Приложите скрин аналогичный уроку и ссылку на гитхаб с кодом. 

# Flask. Урок 2. Маршруты

## 1. Понятие маршрутов (routes)
**Маршрут** — это URL, который связывается с функцией обработки запросов.
* Веб-приложение состоит из страниц, каждая из которых доступна по своему адресу.
* Flask позволяет настраивать маршруты для обработки запросов пользователей.
* Например, маршрут </about> может отображать страницу с информацией "О нас".

## 2. Создание маршрутов с использованием @app.route
Маршруты задаются с помощью декоратора *@app.route*. Пример:
```
@app.route("/")  
def home():  
    return "This is the homepage!"  
```
Ключевые моменты:
* <@app.route("/")>: связывает функцию с адресом </>.
* Функция <home> вызывается при переходе пользователя на указанный маршрут.
* Функция должна возвращать строку или HTML.

**Пример с несколькими маршрутами:**
```
@app.route("/about")
def about():
    return "About page"

@app.route("/contact")
def contact():
    return "Contact page"
```
Теперь:
* При переходе на </about> отображается текст "About page".
* При переходе на </contact> — "Contact page".
![Alt text](/app/static/images/2.png)

## Динамические маршруты и параметры в URL
Flask позволяет задавать маршруты с параметрами. Пример:
```
@app.route("/greet/<name>")
def greet(name):
    return f"Hello, {name}!"
```
Теперь:

При переходе на </greet/Anna> сервер вернет "Hello, Anna!".
При переходе на </greet/John> — "Hello, John!".

## **Типизация параметров**
Можно указать тип данных параметра:

* <int:age>: принимает только целые числа.
* <float:score>: принимает числа с плавающей запятой.
* <path:subpath>: принимает полный подпуть (включая слэши).  
Пример:
```
@app.route("/user/<int:id>")
def user_profile(id):
    return f"User ID: {id}"
```
* </user/123> → "User ID: 123".
* </user/abc> → ошибка, так как <abc> не является числом.

## **Задание**
#### Задание 1: Простые маршруты

Создайте маршруты:
- </hello> с текстом "Hello, world!".
- </info> с текстом "This is an informational page.".

### Задание 2: Динамические маршруты

Реализуйте маршрут </calc//>, который возвращает сумму двух чисел. 
Пример: </calc/3/5> вернет "The sum of 3 and 5 is 8.".

### Задание 3. Создайте маршрут /reverse/, который переворачивает текст.

Пример: /reverse/hello → "olleh".

### Задание 4. Реализуйте маршрут /user//, возвращающий:

"Hello, {name}. You are {age} years old.".  

**Проверьте работу маршрутов в браузере, перейдя по указанным адресам**:

#### Задание 1: Простые маршруты

/hello → Отображает "Hello, world!"

/info → Отображает "This is an informational page."

#### Задание 2: Сумма чисел

/calc/3/5 → Отображает "The sum of 3 and 5 is 8."

#### Задание 3: Переворот текста

/reverse/hello → Отображает "olleh".

/reverse/python → Отображает "nohtyp".

#### Задание 4: Приветствие с возрастом

/user/Anna/25 → Отображает "Hello, Anna. You are 25 years old."

/user/John/30 → Отображает "Hello, John. You are 30 years old."

### Расширение задания:
Добавьте обработку ошибок для неправильных данных (например, /calc/a/b).  
Для маршрута /reverse/ добавьте проверку, чтобы текст содержал хотя бы один символ.  
Для маршрута /user// добавьте валидацию возраста (например, не допускайте возраст меньше 0).

# Flask. Урок 3. Оптимизация структуры проекта во Flask

## 1. Зачем нужна оптимизация структуры проекта?

При разработке маленького приложения простой файл <app.py> может быть достаточным. Однако с ростом функционала проект становится сложнее:
* Трудно находить нужные части кода.
* Код становится плохо читаемым.
* Изменения в одной части приложения могут нарушить другие части.
Хорошая структура:  
* Делит приложение на логически связанные модули.
* Упрощает поддержку и расширение.
* Делает проект удобным для работы в команде.

## 2. Базовая структура небольшого проекта
 
Для небольших приложений простая структура подходит:
```
project/
├── app.py             # Основной файл приложения
├── templates/         # HTML-шаблоны
│   ├── base.html
│   ├── index.html
├── static/            # Статические файлы (CSS, JS, изображения)
│   ├── css/
│   │   └── style.css
└── requirements.txt   # Зависимости
```
Недостатки:
* С ростом проекта логика маршрутов, моделей и обработчиков данных переплетается, что усложняет управление.
## 3. Оптимизированная структура для среднего/большого проекта
Для масштабируемых приложений рекомендуется использовать более сложную структуру:
```
project/
├── app/               # Пакет приложения
│   ├── __init__.py    # Инициализация приложения
│   ├── routes.py      # Маршруты
│   ├── models.py      # Модели базы данных
│   ├── templates/     # HTML-шаблоны
│   │   ├── base.html
│   │   ├── index.html
│   ├── static/        # Статические файлы
│   │   ├── css/
│   │   │   └── style.css
│   │   └── images/
├── config.py          # Конфигурация приложения
├── run.py             # Точка входа в приложение
├── requirements.txt   # Зависимости
└── migrations/        # Миграции базы данных (если используется Flask-Migrate)
```
**Что здесь происходит?**
* `app/`: Основной пакет приложения, где хранятся модули, маршруты и шаблоны.
* `config.py`: Настройки приложения (например, параметры базы данных).
* `run.py`: Запуск приложения.
* `migrations/`: Каталог для управления миграциями базы данных.

## 4. Использование Blueprints для модульности
**Что такое Blueprints?**

Blueprints позволяют делить приложение на независимые модули. Например:

* `auth`: для аутентификации.
* `blog`: для управления постами.  
**Пример с использованием Blueprints**  
Структура проекта:
```
project/
├── app/
│   ├── __init__.py
│   ├── auth/
│   │   ├── __init__.py
│   │   ├── routes.py
│   ├── blog/
│   │   ├── __init__.py
│   │   ├── routes.py
│   ├── templates/
│   └── static/
├── config.py
├── run.py
```
Подробная статья для изучения: https://realpython.com/flask-blueprint/

### Оптимизируем код из прошлого урока

#### Шаги:

**Создание структуры проекта**: В первую очередь, разделим код на несколько частей. Для этого создадим структуру проекта:
* 
```
flask_project/
├── app/
│   ├── __init__.py
│   ├── routes.py
├── run.py
├── requirements.txt
```

* **flask_project/** — корневая директория проекта (у вас может быть другое название)
* **requirements.txt** — файл, где указаны зависимости проекта.
* **run.py** — файл для запуска приложения.
* **routes.py** — хранит все маршруты и соответствующие им функции.
* **init.py** — инициализирует Flask-приложение и импортирует маршруты.
* **app/** — директория для логики приложения.

Файл `requirements.txt`:
1. В этом файле указываются все библиотеки и пакеты, необходимые для работы приложения. В нашем случае, для работы с Flask, мы укажем только эту зависимость:
```
Flask==2.2.3
```
**Flask==2.2.3** — указывает на необходимую версию Flask. Вы можете использовать другую версию, если это необходимо для совместимости с вашим кодом.  
**Файл** `run.py`: В этом файле запускаем наше приложение. Код будет следующим:
* 
```
from app import app

if __name__ == "__main__":
    app.run(debug=True)
```
* **app.run(debug=True)** — запускаем сервер Flask в режиме отладки (это позволяет автоматически перезапускать сервер при изменениях в коде и отображать подробные ошибки).
* **from app import app** — импортируем приложение, которое было создано в `app/__init__.py`.  
**Файл** `app/__init__.py`: Инициализируем наше приложение и подключим маршруты. Этот файл будет выглядеть так:
* 
```
from flask import Flask

app = Flask(__name__)
from app import routes
```
* **from app import routes** — импортируем маршруты, определенные в файле `routes.py`. Это позволяет нам подключить все маршруты к нашему приложению.  
**Файл** `app/routes.py`: Здесь мы переносим всю логику маршрутов. Каждый маршрут привязан к функции, которая будет выполняться при обращении к соответствующему URL. Для упрощения, в этом файле прописаны несколько базовых маршрутов.
* 
```
from app import app

@app.route("/hello")
def hello():
    return "Hello, world!"

@app.route("/info")
def info():
    return "This is an informational page."

#и все оставшиеся маршруты 
```
* **Запуск проекта:** Для запуска проекта выполните команду:
```
python run.py
```
![Alt text](/app/static/images/3.png)
## Задание
Приложите гитхаб проекта с правильной файловой структурой  

# Flask. Урок 4. Режимы работы сервера Flask: Debug Mode и Production Mode
Давайте добавим в наш код ошибку (любую). Например деление на ноль
![Alt text](/app/static/images/4.png)
Flask, как и многие другие веб-фреймворки, имеет два основных режима работы сервера: **режим отладки** (Debug Mode) и **продакшн-режим** (Production Mode). В этом уроке мы подробно рассмотрим, чем они отличаются, как их включать и когда использовать каждый из них.

## 1. Что такое режимы работы сервера?
* **Debug Mode** — это режим, при котором Flask запускается с дополнительной функциональностью для разработчиков. В этом режиме сервер автоматически перезапускается при изменении исходного кода, а ошибки выводятся с подробной информацией о стеке. Это очень удобно при разработке, так как позволяет быстро тестировать изменения.
* **Production Mode** — это режим, предназначенный для реальных пользователей. В этом режиме Flask работает более эффективно, не показывая подробных сообщений об ошибках и не перезапуская сервер автоматически при изменениях в коде. Это обеспечивает стабильную работу приложения в реальной среде.

## 2. Режим отладки (Debug Mode)
Включение режима отладки позволяет Flask выполнять следующие действия:
* Автоматически перезапускать сервер при изменениях в коде.
* Отображать подробные ошибки в браузере, включая информацию о стеке вызовов и переменных.
* Включать трассировку ошибок (stack trace), чтобы быстро отлавливать ошибки в коде.  
Как включить режим отладки?  
Чтобы включить **Debug Mode**, нужно установить значение параметра `debug` в `True` при запуске приложения Flask:
```
if __name__ == "__main__":
    app.run(debug=True)  # Включаем отладку
```
Что делает эта строка?  

* **app.run(debug=True)** — запускает сервер в режиме отладки. В этом режиме сервер будет перезапускаться, если вы внесете изменения в код, а также будет показывать подробные ошибки при возникновении исключений.  

Особенности режима отладки:
* **Автоматический перезапуск:** сервер перезапустится, как только вы измените код.
* **Подробные ошибки:** при возникновении ошибки Flask покажет подробную информацию о проблеме.
* **Преимущества:** быстрое тестирование, удобное отлавливание ошибок.  
Недостатки:
* **Не рекомендуется для продакшн-среды:** Включение режима отладки на сервере с реальными пользователями может представлять угрозу безопасности, так как подробные ошибки могут содержать конфиденциальную информацию.

Теперь переходим на http://127.0.0.1:5000/hello (укажите маршрут с ошибкой в коде)

![Alt text](/app/static/images/5.png)
На странице будет выведена полная информация о возникшей ошибке, полный
Traceback и даже строчка кода, на которой возникла ошибка  
**Важно: эту информация ни в коем случае не должны видеть обычные посетители сайта, потому что здесь содержатся полные данные о нашем сервере. Получив такие данные, злоумышленники легко смогут взломать сайт.
Именно поэтому сервер запускается по умолчанию с выключенным режимом отладки.  
Очень важно: никогда не используй Debug = on на продакшене!**

## 3. Режим продакшн (Production Mode)
В режиме продакшн Flask работает более стабильно и безопасно. Однако в этом режиме:
* Сервер не перезапускается автоматически при изменениях в коде.
* Ошибки не выводятся на экран, а вместо этого пользователю показывается стандартное сообщение об ошибке (например, 500 Internal Server Error).
* Этот режим является предпочтительным для развертывания на реальных серверах.  

Как выключить режим отладки?  
Для отключения отладки установите параметр `debug` в `False` или просто не передавайте его при запуске приложения.
```
if __name__ == "__main__":
    app.run(debug=False)  # Отключаем отладку (режим продакшн)
```
**Что делает эта строка?**

* **app.run(debug=False)** — запускает сервер без режима отладки. В этом случае Flask не будет перезапускаться автоматически, и ошибки не будут отображаться в браузере.
Особенности режима продакшн:
* **Без автоматического перезапуска:** изменения в коде не вызовут перезапуск сервера.
* **Ошибки скрыты:** подробные сообщения об ошибках не будут показываться пользователю.
* **Преимущества:** безопасная и стабильная работа на реальном сервере.
* **Недостатки:** не так удобно отлаживать приложение, так как ошибки не выводятся на экран.  

Переходим на http://127.0.0.1:5000/hello и видим следующее
![Alt text](/app/static/images/6.png)

## 4. Как выбрать режим работы сервера?

* **Используйте Debug Mode:**

- На этапе разработки.
- Для быстрого тестирования изменений.
- Когда вам нужно отслеживать и отлаживать ошибки.
* **Используйте Production Mode:**

- На этапе развертывания приложения.
- Когда ваше приложение будет использоваться реальными пользователями.
- Чтобы минимизировать риски безопасности и улучшить производительность.

# Flask. Урок 5. Работа с HTML и подключение шаблонов в Flask

## Цель урока: Научиться подключать HTML-файлы в Flask и понимать, как сервер "рендерит" страницы для отображения в браузере клиента.

## 1. Что такое рендеринг HTML?

Когда вы переходите на сайт в браузере, ваш компьютер (клиент) запрашивает у сервера данные. Сервер отправляет HTML-код — это текстовый формат, который браузер интерпретирует и показывает в виде веб-страницы.  

**Рендеринг HTML** — это процесс создания HTML-кода на сервере и отправки его клиенту. В Flask для рендеринга HTML используется встроенная функция `render_template`.  

Зачем рендерить HTML в Flask?
* Чтобы клиент получал уже готовую веб-страницу.
* Для разделения логики приложения и его внешнего вида.
* Чтобы сервер мог подготавливать разные страницы для каждого запроса.

## 2. Как подключить HTML в Flask?

Flask позволяет отправлять HTML-страницы клиенту. Эти страницы сохраняются в папке `templates`, которая автоматически распознается Flask.

## 3. Пошаговая реализация

Шаг 1: Создаем проект  
Создайте следующую структуру проекта:
```
flask_project/
├── app/
│   ├── __init__.py
│   ├── routes.py
│   ├── templates/
│   │   ├── index.html
│   │   ├── about.html
├── run.py
```
Шаг 2: Настраиваем приложение  
Создайте файл run.py, который запускает приложение:
```
from app import app

if __name__ == "__main__":
    app.run(debug=True)
```
Создайте файл `app/__init__.py`, который инициализирует приложение:
```
from flask import Flask

app = Flask(__name__)

from app import routes
```
Создайте файл `app/routes.py`, где будут определены маршруты:
```
from flask import render_template
from app import app

@app.route("/")
def home():
    return render_template("index.html")

@app.route("/about")
def about():
    return render_template("about.html")
```
Шаг 3: Создаем HTML-шаблоны  
Создайте папку `templates` в директории `app` и добавьте туда HTML-файлы.  
Файл `templates/index.html`:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
</head>
<body>
    <h1>Welcome to Flask</h1>
    <p>This is the home page of our Flask application.</p>
</body>
</html>
```
Файл `templates/about.html`:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>About</title>
</head>
<body>
    <h1>About Us</h1>
    <p>This page provides information about our application.</p>
</body>
</html>
```
## 4. Запуск приложения
1. Убедитесь, что Flask установлен:
```
pip install flask
```
2. Запустите сервер:
```
python run.py
```
3. Откройте браузер и перейдите по адресу:
* http://127.0.0.1:5000/ — главная страница.
* http://127.0.0.1:5000/about — страница "О нас".

## 5. Как это работает?
1. Когда пользователь открывает в браузере http://127.0.0.1:5000/, клиент отправляет запрос на сервер.
2. Сервер, видя, что запрошен маршрут `/`, вызывает функцию `home` в `routes.py`.
3. Функция `home` использует метод `render_template`, чтобы "рендерить" (собрать) HTML из файла `templates/index.html`.
4. Flask отправляет этот HTML-код клиенту.
5. Браузер получает HTML и отображает страницу.

# 6. Преимущества подхода с HTML-шаблонами
1. **Удобство разработки:**
* Все HTML-файлы хранятся отдельно от Python-кода.
* Легче работать с дизайном и логикой отдельно.
2. Улучшение читаемости:
* Вместо того чтобы писать HTML прямо в Python-файлах, весь код дизайна хранится в одном месте.
3. Повторное использование:
* HTML-файлы можно использовать снова, подключая их к разным маршрутам.

## Задание
**Домашнее задание**  
1. Добавьте новую страницу: Создайте маршрут /contact, который рендерит HTML-файл contact.html. В этом файле укажите заголовок и текст с контактной информацией.
2. Измените главную страницу: На странице / добавьте ссылки на страницы /about и /contact.
**Пример ссылки в HTML: `<a href="/about">About Us</a>`**
3. Попробуйте изменить HTML: Попробуйте добавить новые элементы на страницы, например, изображения, списки или таблицы.

# Flask. Урок 6. Статические файлы во Flask

## Статические файлы во Flask  

**Статические файлы** – это файлы, которые не изменяются во время выполнения приложения. Обычно это файлы CSS, JavaScript, изображения, шрифты и другие ресурсы, необходимые для отображения интерфейса приложения.
Во Flask есть встроенная поддержка статических файлов, и они размещаются в папке с названием `static`.

# Где хранить статические файлы?

По умолчанию, Flask ожидает, что все статические файлы будут находиться в папке `static` в корневой директории проекта.  
Например:
```
project/
├── app/
│   ├── __init__.py
│   ├── routes.py
│   ├── static/
│   │   ├── css/
│   │   │   └── styles.css
│   │   ├── js/
│   │   │   └── script.js
│   │   └── img/
│   │       └── logo.png
│   ├── templates/
│   │   └── index.html
```

## Как подключить статические файлы в HTML?

В HTML-шаблонах Flask мы используем функцию `url_for('static', filename='путь_к_файлу')`, чтобы динамически сформировать путь к статическому файлу. Это удобно, так как Flask сам корректно генерирует URL.  
Примеры:
1. **Подключение CSS:**
```
<link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
```
2. **Подключение JavaScript:**
```
<script src="{{ url_for('static', filename='js/script.js') }}"></script>
```
3. Подключение изображения:
```
<img src="{{ url_for('static', filename='img/logo.png') }}" alt="Logo">
```
# Пример использования статических файлов
1. Создайте файл `app/static/css/styles.css` со следующим содержимым:
```
body {
    font-family: Arial, sans-serif;
    background-color: #f9f9f9;
    margin: 0;
    padding: 0;
}

h1 {
    color: #333;
    text-align: center;
    margin-top: 20px;
}
```
2. В шаблоне `templates/index.html` подключите CSS-файл:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Files Example</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <h1>Welcome to Flask!</h1>
</body>
</html>
```
3. После запуска Flask-приложения (например, с файлом `run.py`), вы увидите стилизованную страницу.

## Дополнительно: Настройка папки для статических файлов  
По умолчанию Flask использует папку `static`, но вы можете изменить её, передав параметр `static_folder` при создании экземпляра приложения:
```
from flask import Flask

app = Flask(__name__, static_folder='my_static')
```

Теперь Flask будет искать статические файлы в папке `my_static`.

## Полезные советы
1. **Организация статических файлов:** Разделяйте файлы на подпапки (`css`, `js`, `img`), чтобы упростить структуру проекта.

2. **Кэширование:** При разработке в браузере может сохраняться кэш старых версий статических файлов. Используйте уникальные версии файлов в URL:
```
<link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}?v=1.0">
```

# Flask. Урок 7. Что такое базовый шаблон (base.html)?

Базовый шаблон (`base.html`) в Flask используется для создания основной структуры HTML-документа, которая повторяется на всех страницах веб-приложения. Вместо того чтобы дублировать общий код (например, `<head>`, шапку сайта, меню или подвал) в каждом шаблоне, вы создаёте базовый шаблон и наследуете его в других страницах.

## **Зачем нужен `base.html`?**
1. **Упрощение кода:** Вместо копирования одинакового HTML на каждой странице, общий код пишется в одном месте.
2. **Лёгкость изменений:** Изменение в базовом шаблоне сразу отразится на всех страницах, которые его используют.
3. **Организация:** Делает структуру проекта более чистой и удобной для работы.
## **Как создаётся `base.html`?**
Базовый шаблон содержит общую структуру веб-страницы и точки для вставки контента с помощью специальных блоков (`blocks`).  

**Пример base.html:**
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}My Flask App{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <!-- Шапка -->
    <header>
        <h1>My Flask App</h1>
        <nav>
            <a href="/">Home</a>
            <a href="/about">About</a>
            <a href="/contact">Contact</a>
        </nav>
    </header>

    <!-- Основной контент -->
    <main>
        {% block content %}
        <!-- Контент будет вставляться здесь -->
        {% endblock %}
    </main>

    <!-- Подвал -->
    <footer>
        <p>&copy; 2025 My Flask App</p>
    </footer>
</body>
</html>
```
## Объяснение структуры `base.html`
1. **Шапка сайта:**

* Содержит заголовок и меню навигации.
* Дублируется на всех страницах.
2. **{% block title %}**:

* Указывает место для изменения заголовка страницы.
* Например, на одной странице это может быть "Home", а на другой "About Us".
3. **{% block content %}:**

* Указывает место для основного контента страницы.
* Другие шаблоны, которые наследуют base.html, будут вставлять сюда свои данные.
4. **Подвал (footer):**
* Фиксированная часть, которая также повторяется на всех страницах.  

## **Наследование базового шаблона**
Чтобы использовать `base.html`, создайте дополнительные шаблоны и наследуйте его с помощью `{% extends 'base.html' %}`.  
**Пример: `home.html:`**
```
{% extends 'base.html' %}

{% block title %}Home{% endblock %}

{% block content %}
    <h2>Welcome to My Flask App!</h2>
    <p>This is the home page of our website.</p>
{% endblock %}
```
**Пример: `about.html`:**
```
{% extends 'base.html' %}

{% block title %}About Us{% endblock %}

{% block content %}
    <h2>About Us</h2>
    <p>This page provides information about our company.</p>
{% endblock %}
```

## **Как подключить базовый шаблон в проекте?**
1. **Создайте файл `templates/base.html`**:
* Добавьте общий код HTML.
2. **Создайте страницы, которые будут его наследовать:**
* Например, `home.html`, `about.html`, `contact.html`.
3. **Настройте маршруты в `routes.py`:**
```
@app.route("/")
def home():
    return render_template("home.html")

@app.route("/about")
def about():
    return render_template("about.html")

@app.route("/contact")
def contact():
    return render_template("contact.html")
```
## **Что делать, если нужно добавить стили или скрипты на конкретную страницу?**  

Вы можете использовать дополнительные блоки для подключения индивидуальных CSS или JavaScript.  
**Пример: Добавление скриптов или стилей в `base.html`:**
```
<head>
    <title>{% block title %}My Flask App{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    {% block extra_css %}{% endblock %}
</head>
<body>
    ...
    {% block extra_js %}{% endblock %}
</body>
```
**В дочернем шаблоне (например, `contact.html`):**
```
{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/contact.css') }}">
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/contact.js') }}"></script>
{% endblock %}
```

## **Преимущества использования `base.html`**
1. **Повторное использование:** Нет необходимости дублировать общие элементы страницы.
2. **Удобство обновления:** Любое изменение в базовом шаблоне сразу распространяется на все дочерние страницы.
3. **Чистота кода:** Каждая страница содержит только свой уникальный контент, что делает код более читаемым и организованным.

# Flask. Урок 8. Создание формы и обработка POST и GET запросов

## 1. Что такое GET и POST запросы?

* **GET:**
- Используется для получения данных с сервера.
- Данные передаются через URL (в строке запроса, после ?).
- Пример: пользователь переходит по ссылке: http://example.com/search?query=python.
* POST:
- Используется для отправки данных на сервер.
- Данные передаются в теле HTTP-запроса, а не в URL.
- Используется для передачи данных, например, из форм.
## 2. Задача урока

Мы создадим форму, которая будет:
1. Отображаться на главной странице (/).
2. При отправке данных через форму, перенаправлять пользователя на другую страницу (/submit) и показывать введённую информацию.
## 3. Пошаговое выполнение

Шаг 1: Подготовка проекта  

Создайте структуру проекта:
```
flask_form_project/
├── app/
│   ├── __init__.py
│   ├── routes.py
│   ├── templates/
│   │   ├── form.html
│   │   ├── result.html
├── run.py
```

Шаг 2: Настройка Flask-приложения  

1. `run.py`: Запускает приложение:
```
from app import app

if __name__ == "__main__":
    app.run(debug=True)
```

2. `app/__init__.py`: Инициализирует приложение:

```
from flask import Flask
app = Flask(__name__)
from app import routes
```

3. `app/routes.py`: Создайте маршруты для отображения формы и обработки данных.

Шаг 3: Создание HTML-формы  

Создайте файл `templates/form.html` для отображения формы:

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Example</title>
</head>
<body>
    <h1>Enter Your Details</h1>
    <form action="/submit" method="POST">
        <label for="name">Name:</label>
        <input type="text" id="name" name="name" required><br><br>

        <label for="email">Email:</label>
        <input type="email" id="email" name="email" required><br><br>

        <button type="submit">Submit</button>
    </form>
</body>
</html>
```

**Объяснение:**

* `<form>`: Создаёт форму.
- `action="/submit"`: Указывает, куда отправлять данные (на маршрут /submit).
- `method="POST"`: Указывает, что данные формы будут отправлены методом POST.
* `<input>`: Поля ввода для имени и email.
* `<button>`: Кнопка для отправки данных.  

Шаг 4: Создание маршрутов  

Добавьте в файл `app/routes.py`:
```
from flask import render_template, request, redirect, url_for
from app import app

@app.route("/")
def form():
    return render_template("form.html")

@app.route("/submit", methods=["POST", "GET"])
def submit():
    if request.method == "POST":
        name = request.form.get("name")  # Получаем имя из формы
        email = request.form.get("email")  # Получаем email из формы
        return render_template("result.html", name=name, email=email)
    else:
        return redirect(url_for("form"))  # Если запрос GET, возвращаем на форму
```

**Объяснение:**

1. **Маршрут** `/`:

* Метод `GET` (по умолчанию).
* Показывает страницу с формой (`form.html`).
2. Маршрут `/submit`:

* При POST запросе:
- Получает данные из формы через request.form.get.
- Передаёт данные в шаблон result.html.
* При GET запросе:
- Перенаправляет обратно на главную страницу.  

Шаг 5: Создание результата  

Создайте файл `templates/result.html` для отображения результата:

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Submission Result</title>
</head>
<body>
    <h1>Submission Successful</h1>
    <p>Thank you, <strong>{{ name }}</strong>!</p>
    <p>We have sent a confirmation to <strong>{{ email }}</strong>.</p>
    <a href="/">Go back to form</a>
</body>
</html>
```
**Объяснение:**

* Данные, переданные из маршрута /submit, отображаются через переменные {{ name }} и {{ email }}.
* Ссылка Go back to form возвращает пользователя на главную страницу.
  
## Проверка работы приложения
 
1. Запустите приложение:
```
python run.py
```
2. Перейдите по адресу http://127.0.0.1:5000:
* Заполните форму и отправьте данные.
* Убедитесь, что результат отображается на странице /submit.
3. Попробуйте перейти на /submit без отправки формы (метод GET). Проверьте, что вы перенаправлены обратно на главную страницу.

### Вид главной страницы

![Alt text](/app/static/images/8.png)

### После отправки формы

![Alt text](/app/static/images/9.png)

### Пытаемся отправить форму без данных

![Alt text](/app/static/images/10.png)

## Добавляем "смешные" стили для формы

Сейчас мы стилизуем форму так, чтобы она выглядела забавно и нестандартно. Это может быть форма с необычными цветами, большими шрифтами, неожиданным поведением кнопок и странным расположением элементов. Вот как это сделать!

 

## **Обновление HTML-формы**
Изменим HTML-структуру формы, добавив классы для стилизации:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funny Form</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <h1 class="funny-title">😄 Enter Your Details! 🦄</h1>
    <form action="/submit" method="POST" class="funny-form">
        <label for="name">Your Super Cool Name:</label>
        <input type="text" id="name" name="name" required><br><br>

        <label for="email">Your Awesome Email:</label>
        <input type="email" id="email" name="email" required><br><br>

        <button type="submit" class="funny-button">🚀 Let's Go!</button>
    </form>
</body>
</html>
```
## Стили для "смешной" формы
Создайте файл `app/static/css/styles.css` и добавьте следующие стили:

```
/* Общее стилизование */
body {
    font-family: "Comic Sans MS", cursive, sans-serif;
    background-color: #fffb91;
    text-align: center;
    margin: 0;
    padding: 0;
}

/* Заголовок */
.funny-title {
    font-size: 3rem;
    color: #ff69b4;
    text-shadow: 3px 3px #ffa500;
    margin-top: 20px;
    animation: wobble 2s infinite;
}

/* Анимация для заголовка */
@keyframes wobble {
    0%, 100% {
        transform: rotate(-5deg);
    }
    50% {
        transform: rotate(5deg);
    }
}

/* Стили формы */
.funny-form {
    margin: 50px auto;
    padding: 20px;
    width: 400px;
    background-color: #ffe4e1;
    border: 5px dashed #ff4500;
    border-radius: 20px;
    box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
    transform: rotate(-2deg);
}

/* Поля ввода */
.funny-form input[type="text"],
.funny-form input[type="email"] {
    width: 80%;
    padding: 10px;
    margin: 10px 0;
    border: 2px solid #ff1493;
    border-radius: 10px;
    font-size: 1.2rem;
    background-color: #fffaf0;
}

/* Поля ввода: при наведении */
.funny-form input[type="text"]:hover,
.funny-form input[type="email"]:hover {
    background-color: #ffd700;
    transform: scale(1.1);
    transition: 0.3s ease;
}

/* Кнопка */
.funny-button {
    background-color: #ff4500;
    color: white;
    font-size: 1.5rem;
    padding: 10px 20px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
    animation: bounce 1s infinite;
}

/* Анимация кнопки */
@keyframes bounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-10px);
    }
}

/* Кнопка: при наведении */
.funny-button:hover {
    background-color: #ff6347;
    transform: scale(1.2);
    transition: 0.3s ease;
}
```

## Что делает этот стиль?
1. **Яркие цвета:**

* Фон формы жёлтого цвета (#fffb91), а кнопки — ярко-оранжевые и розовые.
* Всплывающие элементы (hover) изменяют цвет и увеличиваются.
2. Анимации:

* Заголовок качается влево-вправо с помощью анимации wobble.
* Кнопка "скачет" вверх-вниз с помощью анимации bounce.
3. Странная форма:

* Форма имеет "наклон" благодаря transform: rotate(-2deg).
* Границы формы — пунктирные, с ярко-оранжевым цветом.
4. Интерактивность:

* Поля ввода увеличиваются и меняют цвет, когда на них наводится курсор.
* Кнопка увеличивается при наведении

![Alt text](/app/static/images/11.png)

## **Задание: Доработка "смешной" формы**

`Примечание: если вам не нравится дизайн из урока - вы вправе полностью изменить его на свой` 

Цель задания — доработать проект с формой, добавив новые элементы, интерактивность и дополнительные стили. 

## Условия задания
1. **Добавьте новые поля в форму:**

* Поле выбора любимого цвета (`<input type="color"`>).
* Выпадающий список с выбором профессии (`<select>`).
* Чекбоксы для выбора увлечений (например: "Книги", "Спорт", "Игры").
* Переключатель (`<input type="radio">`) для выбора типа пользователя (например, "Новичок", "Продвинутый").
2. **Измените стили для новых элементов:**

* Чекбоксы и переключатели должны выглядеть необычно (например, добавьте значки или анимацию).
* Цвета из `<input type="color">` должны отображаться в превью рядом с полем.
3. **Добавьте кнопку-сюрприз:**

* Создайте вторую кнопку с текстом "Нажми меня". При нажатии на неё на форме должны появляться дополнительные элементы или смешное сообщение.
4. Добавьте динамическое сообщение:

* После отправки формы пользователю нужно отобразить все выбранные параметры (например: "Спасибо, Алексей! Ваш любимый цвет — синий, а профессия — разработчик. Вы указали, что увлекаетесь спортом и играми.").
## **Подсказки**
Поля для ввода
1. Поле выбора цвета:
```
<label for="color">Your Favorite Color:</label>
<input type="color" id="color" name="color">
```
2. Выпадающий список:
```
<label for="profession">Your Profession:</label>
<select id="profession" name="profession">
    <option value="developer">Developer</option>
    <option value="designer">Designer</option>
    <option value="manager">Manager</option>
</select>
```
3. Чекбоксы:
```
<p>Your Hobbies:</p>
<label><input type="checkbox" name="hobbies" value="books"> Books</label>
<label><input type="checkbox" name="hobbies" value="sports"> Sports</label>
<label><input type="checkbox" name="hobbies" value="games"> Games</label>
```
4. Переключатели:
```
<p>Your Level:</p>
<label><input type="radio" name="level" value="beginner"> Beginner</label>
<label><input type="radio" name="level" value="advanced"> Advanced</label>
```
Динамическое отображение данных после отправки
1. В маршруте `/submit` обработайте данные формы и передайте их в шаблон:
```
name = request.form.get("name")
color = request.form.get("color")
profession = request.form.get("profession")
hobbies = request.form.getlist("hobbies")  # Для чекбоксов
level = request.form.get("level")
```
2. Отобразите эти данные в шаблоне:
```
<h1>Thank You, {{ name }}!</h1>
<p>Your favorite color is: <span style="color: {{ color }}">{{ color }}</span>.</p>
<p>Your profession is: {{ profession }}.</p>
<p>Your hobbies: {{ hobbies | join(', ') }}.</p>
<p>Your level: {{ level }}.</p>
```
## **Дополнительные задания (по желанию)**
1. Случайная шутка:
* Добавьте на страницу результат случайную смешную шутку, которая выбирается из заранее заданного списка.
2. Анимация кнопки-сюрприза:
* Добавьте анимацию для кнопки-сюрприза (например, она может убегать от курсора).
3. Проверка формы:
* Если пользователь не заполнил какое-то поле, покажите смешное сообщение об ошибке (например, "Мы не можем обработать форму без вашего имени, мистер Аноним!").
## Пример результата
1. **Форма с новыми элементами:**
* Поле выбора цвета.
* Выпадающий список.
* Чекбоксы и переключатели.
2. Результат после отправки:
```
Спасибо, Алексей!
Ваш любимый цвет — синий.
Ваша профессия — разработчик.
Ваши увлечения: книги, спорт.
Вы — Продвинутый.
```
3. Кнопка-сюрприз:
* При нажатии добавляет текст: "Ты нашёл секретную кнопку! Поздравляем!"
## **Задание**
Приложите ссылку на гитхаб с решением задания к Уроку 8. Создание формы и обработка POST и GET запросов

# Flask. Практикум 1. Создание контактной формы с использованием HTML, CSS и Flask

## Разработка веб-приложения на Flask

Ваша задача — разработать простое веб-приложение с использованием Flask, которое будет включать несколько страниц и функциональность для обработки формы.

## Описание приложения

Приложение должно включать следующие страницы:  

**Главная страница (Home)** — на которой будет отображаться приветственное сообщение и краткая информация о сайте.

![Alt text](/app/static/images/12.png)

**Страница "О нас" (About)** — на которой будет представлена информация о проекте или команде разработчиков.

![Alt text](/app/static/images/13.png)

**Страница "Контакты" (Contact)** — с формой для отправки сообщения.

![Alt text](/app/static/images/14.png)

Форма на странице "Контакты" должна принимать данные пользователя, такие как имя, email и сообщение. После отправки формы, приложение должно отображать сообщение о том, что сообщение было успешно отправлено.

![Alt text](/app/static/images/15.png)

## Основные требования

1. **Установка и настройка Flask:**
* Используйте Flask для создания приложения.
* Приложение должно быть запущено на локальном сервере.
2. **Структура проекта:** Структура проекта должна быть следующей:
```
/project
├── /app
│   ├── __init__.py         # Инициализация Flask-приложения
│   ├── routes.py           # Маршруты приложения
│   ├── /templates          # Шаблоны для страниц
│   │   ├── base.html       # Основной шаблон (шапка, футер)
│   │   ├── index.html      # Главная страница
│   │   ├── about.html      # Страница о нас
│   │   └── contact.html    # Страница контактов с формой
│   └── /static
│       └── /css
│           └── styles.css  # Стили для приложения
│       └── /img
│           └── logo.png    # Логотип приложения
├── run.py                  # Запуск приложения
```
3. **Страница "Главная":**

* Отображает приветственное сообщение, краткую информацию о сайте или проекте.
* Включает логотип или изображение.
4. **Страница "О нас":**

* Предоставляет информацию о проекте или команде.
* Включает текстовую информацию и, возможно, список целей, миссии, ценностей.
5. **Страница "Контакты":**

* Содержит форму для ввода:
- Имя пользователя (обязательное поле).
- Email (обязательное поле, с валидацией на корректность).
- Сообщение (обязательное поле).
* При отправке формы, отображается сообщение о том, что сообщение было отправлено.
* Если одно из полей не заполнено или заполнено неправильно (например, неверный формат email), необходимо отобразить сообщение об ошибке.
6. **Маршруты в Flask:**
* Для каждой страницы (главной, о нас, контакты) необходимо создать соответствующий маршрут в Flask.
* Для страницы "Контакты" должен быть реализован обработчик POST-запроса, который обрабатывает данные формы.
7. **Интерфейс:**
* Важно, чтобы приложение было визуально приятным и удобным.
* Используйте CSS для стилизации форм и других элементов.
8. **Подтверждение отправки формы:** После отправки формы, пользователю должно быть показано сообщение о том, что его сообщение успешно отправлено.
9. **Дополнительные требования (опционально):** Реализовать валидацию данных формы (например, проверка, что email введен в правильном формате).

## **Оценка:**
Проект будет оцениваться по следующим критериям:

1. **Правильность работы маршрутов:** приложение должно корректно обрабатывать GET и POST запросы.
2. **Валидация формы:** проверка данных формы и отображение ошибок, если данные введены неверно.
3. **Структура проекта:** правильная организация файлов и папок.
4. **Интерфейс и дизайн:** использование CSS для улучшения визуальной части приложения.
5. **Кодировка и стиль:** чистота кода, использование комментариев и понятных имен для переменных и функций.
## **Задание**
Приложите ссылку на гитхаб с решением проекта Практикум 1 по Flask и скрины всех страниц запущенного сервиса

# Flask. Урок 9. Основы шаблонизации в Flask
## **1. Что такое Jinja2?**
 
**Jinja2** — это мощный и гибкий шаблонизатор для Python. Jinja2 используется для генерации HTML-страниц на основе данных, передаваемых из Python-кода. Это позволяет разделить логику обработки данных и представление, что повышает гибкость и делает код более чистым.

## **2. Зачем использовать Jinja2?**

Jinja2 позволяет:
* **Отделить логику от представления:** в одном месте обрабатываются данные, а в другом — отображаются.
* **Динамически генерировать HTML:** вместо того чтобы вручную писать HTML-код для каждого запроса, вы можете передавать данные в шаблон и автоматически генерировать страницу.
* **Удобные конструкции:** Jinja2 имеет мощные конструкции, такие как циклы, условные операторы, фильтры, макросы, которые упрощают работу с HTML.
 
## **3. Как использовать Jinja2 в Flask?**

Flask встроенно поддерживает Jinja2, и вам не нужно устанавливать дополнительные пакеты, чтобы его использовать. Все, что вам нужно — это подготовить шаблон и передавать данные через маршруты.

## **Основы использования Jinja2 в Flask**

1. **Шаблоны в Flask:** Все HTML-шаблоны Flask хранятся в директории `templates`. Когда Flask рендерит страницу, он ищет HTML-файлы в этой папке и использует Jinja2 для динамического заполнения этих файлов.

2. **Рендеринг шаблонов:** В Flask для рендеринга шаблонов используется функция `render_template`. Например, если у вас есть шаблон index.html, то в маршруте Flask вы можете рендерить его следующим образом:
```
from flask import render_template

@app.route('/')
def home():
    return render_template('index.html')
```

Функция `render_template` ищет файл `index.html` в папке `templates` и передает его для рендеринга.

## **4. Переменные в Jinja2**

В шаблоне Jinja2 вы можете использовать переменные, переданные из Python. Переменные заключаются в двойные фигурные скобки `{{ }}`.  

Пример:
```
@app.route('/')
def home():
    name = 'John'
    return render_template('index.html', user_name=name)
```

В шаблоне `index.html` вы можете использовать переменную `user_name`, переданную из маршрута Flask:
```
<!DOCTYPE html>
<html>
<head>
    <title>Welcome</title>
</head>
<body>
    <h1>Hello, {{ user_name }}!</h1>
</body>
</html>
```
Когда вы откроете страницу, она отобразит:
```
Hello, John!
```
4.1. Использование выражений Jinja2 также поддерживает простые выражения, такие как арифметические операции:
```
<p>The sum of 2 + 3 is: {{ 2 + 3 }}</p>
```
Этот код отобразит:
```
The sum of 2 + 3 is: 5
```
## **5. Циклы в Jinja2**
 
Jinja2 позволяет использовать циклы для повторяющихся элементов. Это полезно, когда вам нужно отобразить список или массив данных.

Пример:  

Допустим, у вас есть список пользователей, и вы хотите отобразить их в виде списка на странице.
```
@app.route('/')
def home():
    users = ['Alice', 'Bob', 'Charlie']
    return render_template('index.html', users_list=users)
```
В шаблоне `index.html` можно использовать цикл `for` для отображения каждого пользователя:
```
<ul>
    {% for user in users_list %}
        <li>{{ user }}</li>
    {% endfor %}
</ul>
```
Этот код отобразит:
```
- Alice
- Bob
- Charlie
```
5.1. Работа с индексами  

Вы также можете работать с индексами элементов списка. Например, для нумерации элементов:
```
<ul>
    {% for user in users_list %}
        <li>{{ loop.index }}. {{ user }}</li>
    {% endfor %}
</ul>
```
Это отобразит:
```
1. Alice
2. Bob
3. Charlie
```
* `loop.index` — это индекс текущего элемента в цикле, начиная с 1.
* `loop.index0` — индекс, начиная с 0.
# **6. Условные операторы в Jinja2**
 
Jinja2 поддерживает условные операторы для вывода данных в зависимости от условий. Вы можете использовать конструкции `if`, `elif` и `else`.

Пример:
```
@app.route('/')
def home():
    is_logged_in = True
    return render_template('index.html', logged_in=is_logged_in)
```

В шаблоне `index.html`:
```
{% if logged_in %}
    <p>Welcome back, user!</p>
{% else %}
    <p>Please log in.</p>
{% endif %}
```
Если переменная `logged_in` равна `True`, на странице отобразится:
```
Welcome back, user!
```
Если `logged_in` будет `False`, отобразится:

Please log in.
## **7. Фильтры в Jinja2**

Jinja2 поддерживает фильтры, которые позволяют изменять выводимые данные. Например, вы можете использовать фильтр `lower`, чтобы привести строку к нижнему регистру:
```
<p>{{ 'Hello World' | lower }}</p>
```
Этот код выведет:
```
hello world
```
## **8. Наследование шаблонов в Jinja2**

Jinja2 позволяет использовать наследование шаблонов, что позволяет создавать базовые шаблоны, которые могут быть расширены другими страницами. Например, создадим основной шаблон base.html, который будет содержать общие элементы, такие как шапка и футер.  

Пример базового шаблона `base.html`:
```
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}My Website{% endblock %}</title>
</head>
<body>
    <header>
        <h1>Welcome to My Website</h1>
    </header>

    <main>
        {% block content %}{% endblock %}
    </main>

    <footer>
        <p>&copy; 2025 My Website</p>
    </footer>
</body>
</html>
```
Теперь, на страницах, которые наследуют этот шаблон, можно определять только нужные блоки.  

Пример страницы, которая наследует `base.html`:
```
{% extends "base.html" %}

{% block title %}Home{% endblock %}

{% block content %}
    <h2>Welcome to the home page!</h2>
{% endblock %}
```

## **9. Передача словарей в шаблон Jinja2**

В Flask вы можете передавать **словарь** (или любые другие сложные структуры данных, такие как списки или объекты) в шаблон, а затем работать с этим словарем в шаблоне. Это полезно, когда вам нужно передавать несколько связанных данных, например, информацию о пользователе или продукте.

Пример передачи словаря:  

Допустим, у вас есть словарь с информацией о пользователе, и вы хотите передать его в шаблон:
```
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def home():
    user_info = {
        'name': 'Alice',
        'age': 30,
        'email': 'alice@example.com'
    }
    return render_template('index.html', user=user_info)
```

В шаблоне `index.html` вы можете обращаться к данным словаря:
```
<!DOCTYPE html>
<html>
<head>
    <title>User Profile</title>
</head>
<body>
    <h1>User Profile</h1>
    <p>Name: {{ user.name }}</p>
    <p>Age: {{ user.age }}</p>
    <p>Email: {{ user.email }}</p>
</body>
</html>
```

Этот код отобразит:
```
User Profile
Name: Alice
Age: 30
Email: alice@example.com
```

Здесь мы передаем словарь `user_info` в шаблон под именем `user`, а затем обращаемся к значениям словаря с помощью `user.name`, `user.age` и т.д.

Работа с вложенными словарями:  

Если у вас есть вложенные словари, вы можете обращаться к их значениям через несколько уровней.
```
@app.route('/')
def home():
    user_info = {
        'name': 'Alice',
        'address': {
            'street': '123 Main St',
            'city': 'Wonderland',
            'zip': '12345'
        }
    }
    return render_template('index.html', user=user_info)
```

В шаблоне `index.html`:
```
<p>Street: {{ user.address.street }}</p>
<p>City: {{ user.address.city }}</p>
<p>ZIP Code: {{ user.address.zip }}</p>
```

Это отобразит:
```
Street: 123 Main St
City: Wonderland
ZIP Code: 12345
```
## **10. Форматирование даты и времени в Jinja2**

Пример передачи даты в шаблон:  

Допустим, у вас есть объект типа `datetime`, который нужно отобразить в шаблоне в определенном формате.
```
from flask import Flask, render_template
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def home():
    current_time = datetime.now()
    return render_template('index.html', current_time=current_time)
```

В шаблоне `index.html` вы можете использовать фильтр `date`, чтобы отформатировать дату и время:

```
<!DOCTYPE html>
<html>
<head>
    <title>Current Time</title>
</head>
<body>
    <h1>Current Time: {{ current_time.strftime('%Y-%m-%d %H:%M:%S') }}</h1>
</body>
</html>
```

Этот код отобразит текущую дату и время в формате `YYYY-MM-DD HH:MM:SS`:
```
Current Time: 2025-01-19 22:30:45
```

Примеры форматов даты:  

Вот несколько примеров, как можно форматировать дату и время с помощью фильтра `date`:

* `{{ current_time.strftime('%Y-%m-%d') }}` — отображает только дату: `2025-01-19`
* `{{ current_time.strftime('%b %d, %Y') }}` — отображает дату в формате: `Jan 19, 2025`
* `{{ current_time.strftime('%A, %B %d, %Y') }}` — отображает дату в формате: `Sunday, January 19, 2025`
* `{{ current_time.strftime('%I:%M %p') }}` — отображает время в 12-часовом формате: `10:30 PM`
## **11. Работа с временем в шаблонах**

Вы можете использовать фильтры для работы с временными метками. Например, можно передать объект `datetime` в шаблон и отобразить его разницу с текущим временем.  

Пример расчета времени:  

Предположим, у вас есть объект `datetime`, который нужно отобразить вместе с информацией о том, сколько времени прошло с этого момента:

```
@app.route('/')
def home():
    event_time = datetime(2025, 1, 19, 14, 30)
    return render_template('index.html', event_time=event_time)
```

В шаблоне `index.html` можно вычислить разницу между текущим временем и временем события:

```
<!DOCTYPE html>
<html>
<head>
    <title>Event</title>
</head>
<body>
    <h1>Event Time: {{ event_time.strftime('%Y-%m-%d %H:%M') }}</h1>
    <p>Time until event: {{ (event_time - current_time).total_seconds() | round(0) }} seconds</p>
</body>
</html>
```

Здесь мы показываем, сколько секунд осталось до события.

## **Заключение**

Jinja2 — это мощный инструмент для создания динамических шаблонов в Flask. Он позволяет вам:
* Передавать сложные структуры данных, такие как словари, и работать с ними в шаблонах.
* Форматировать даты и время, чтобы отобразить их в нужном формате.
* Использовать различные фильтры и конструкции для динамической генерации HTML на основе переданных данных.  

Освоив основы работы с Jinja2, вы сможете создавать более гибкие и динамичные веб-приложения с Flask.

## **Задание**
Доработайте код из предыдущего проекта. 

### Задание 1: Форматирование даты и времени

Цель: Научиться форматировать дату и время в шаблонах с использованием фильтра date.

#### Описание задания:
На странице "Home" (index.html) отобразите текущую дату и время, отформатированные в формате "Сегодня: Понедельник, Январь 19, 2025, 14:30:00".
Дополнительные требования:
Используйте Python-библиотеку datetime для получения текущей даты и времени.
В шаблоне отформатируйте дату с помощью strftime.

### Задание 2: Использование циклов для отображения списка пользователей

Цель: Научиться использовать цикл for для динамического отображения элементов списка.

#### Описание задания:

На странице `"О нас" (about.html)` создайте список из нескольких пользователей с именами и ролями (например, список командных участников).

Отобразите этот список на странице с помощью цикла `for` в шаблоне.

#### Дополнительные требования:

Список пользователей должен быть передан в шаблон как список словарей, где каждый словарь содержит имя и роль пользователя.

Пример: 
```
    team_members = [

    {'name': 'Alice', 'role': 'Developer'},

    {'name': 'Bob', 'role': 'Designer'},

    {'name': 'Charlie', 'role': 'Project Manager'}

]
```

### Задание 3: Вложенные словари и работа с адресами

Цель: Научиться работать с вложенными структурами данных (например, словарями).

#### Описание задания:

На странице "Контакты" (contact.html) создайте и передайте в шаблон словарь с информацией об Отделе заботы о клиентах (или менеджере для связи) и адресе.

В шаблоне отобразите имя и информацию.

#### Дополнительные требования:

Используйте вложенные словари (например, address) и отобразите их данные (улицу, город, почтовый индекс).

# **Flask. Урок 9. Основы шаблонизации в Flask**

## **1. Что такое Jinja2?**
 
**Jinja2** — это мощный и гибкий шаблонизатор для Python. Jinja2 используется для генерации HTML-страниц на основе данных, передаваемых из Python-кода. Это позволяет разделить логику обработки данных и представление, что повышает гибкость и делает код более чистым.

## **2. Зачем использовать Jinja2?**
 
Jinja2 позволяет:  
* **Отделить логику от представления:** в одном месте обрабатываются данные, а в другом — отображаются.
* **Динамически генерировать HTML:** вместо того чтобы вручную писать HTML-код для каждого запроса, вы можете передавать данные в шаблон и автоматически генерировать страницу.
* **Удобные конструкции:** Jinja2 имеет мощные конструкции, такие как циклы, условные операторы, фильтры, макросы, которые упрощают работу с HTML.

## **3. Как использовать Jinja2 в Flask?**

Flask встроенно поддерживает Jinja2, и вам не нужно устанавливать дополнительные пакеты, чтобы его использовать. Все, что вам нужно — это подготовить шаблон и передавать данные через маршруты.

## **Основы использования Jinja2 в Flask**
 
1. **Шаблоны в Flask:** Все HTML-шаблоны Flask хранятся в директории `templates`. Когда Flask рендерит страницу, он ищет HTML-файлы в этой папке и использует Jinja2 для динамического заполнения этих файлов.

2. **Рендеринг шаблонов:** В Flask для рендеринга шаблонов используется функция `render_template`. Например, если у вас есть шаблон `index.html`, то в маршруте Flask вы можете рендерить его следующим образом:
```
from flask import render_template

@app.route('/')
def home():
    return render_template('index.html')
```
Функция `render_template` ищет файл `index.html` в папке templates и передает его для рендеринга.

## **4. Переменные в Jinja2**
 
В шаблоне Jinja2 вы можете использовать переменные, переданные из Python. Переменные заключаются в двойные фигурные скобки `{{ }}`.  

Пример:
```
@app.route('/')
def home():
    name = 'John'
    return render_template('index.html', user_name=name)
```
В шаблоне `index.html` вы можете использовать переменную `user_name`, переданную из маршрута Flask:
```
<!DOCTYPE html>
<html>
<head>
    <title>Welcome</title>
</head>
<body>
    <h1>Hello, {{ user_name }}!</h1>
</body>
</html>
```
Когда вы откроете страницу, она отобразит:
```
Hello, John!
```
### 4.1. Использование выражений
Jinja2 также поддерживает простые выражения, такие как арифметические операции:
```
<p>The sum of 2 + 3 is: {{ 2 + 3 }}</p>
```
Этот код отобразит:
```
The sum of 2 + 3 is: 5
```
## **5. Циклы в Jinja2**

Jinja2 позволяет использовать циклы для повторяющихся элементов. Это полезно, когда вам нужно отобразить список или массив данных.  

Пример:  

Допустим, у вас есть список пользователей, и вы хотите отобразить их в виде списка на странице.
```
@app.route('/')
def home():
    users = ['Alice', 'Bob', 'Charlie']
    return render_template('index.html', users_list=users)
```
В шаблоне `index.html` можно использовать цикл `for` для отображения каждого пользователя:
```
<ul>
    {% for user in users_list %}
        <li>{{ user }}</li>
    {% endfor %}
</ul>
```
Этот код отобразит:
```
- Alice
- Bob
- Charlie
```
### 5.1. Работа с индексами
Вы также можете работать с индексами элементов списка. Например, для нумерации элементов:
```
<ul>
    {% for user in users_list %}
        <li>{{ loop.index }}. {{ user }}</li>
    {% endfor %}
</ul>
```
Это отобразит:
```
1. Alice
2. Bob
3. Charlie
``` 
* `loop.index` — это индекс текущего элемента в цикле, начиная с 1.
* `loop.index0` — индекс, начиная с 0.
## **6. Условные операторы в Jinja2**

Jinja2 поддерживает условные операторы для вывода данных в зависимости от условий. Вы можете использовать конструкции `if`, `elif` и `else`.

Пример:
```
@app.route('/')
def home():
    is_logged_in = True
    return render_template('index.html', logged_in=is_logged_in)
```
В шаблоне `index.html`:
```
{% if logged_in %}
    <p>Welcome back, user!</p>
{% else %}
    <p>Please log in.</p>
{% endif %}
```
Если переменная `logged_in` равна `True`, на странице отобразится:
```
Welcome back, user!
```
Если `logged_in` будет False, отобразится:
```
Please log in.
```
## **7. Фильтры в Jinja2**

Jinja2 поддерживает фильтры, которые позволяют изменять выводимые данные. Например, вы можете использовать фильтр `lower`, чтобы привести строку к нижнему регистру:
```
<p>{{ 'Hello World' | lower }}</p>
```
Этот код выведет:
```
hello world
```
## **8. Наследование шаблонов в Jinja2**
 

Jinja2 позволяет использовать наследование шаблонов, что позволяет создавать базовые шаблоны, которые могут быть расширены другими страницами. Например, создадим основной шаблон `base.html`, который будет содержать общие элементы, такие как шапка и футер.

Пример базового шаблона `base.html`:
```
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}My Website{% endblock %}</title>
</head>
<body>
    <header>
        <h1>Welcome to My Website</h1>
    </header>

    <main>
        {% block content %}{% endblock %}
    </main>

    <footer>
        <p>&copy; 2025 My Website</p>
    </footer>
</body>
</html>
```
Теперь, на страницах, которые наследуют этот шаблон, можно определять только нужные блоки.  

Пример страницы, которая наследует `base.html`:
```
{% extends "base.html" %}

{% block title %}Home{% endblock %}

{% block content %}
    <h2>Welcome to the home page!</h2>
{% endblock %}
```
## **9. Передача словарей в шаблон Jinja2**
 
В Flask вы можете передавать **словарь** (или любые другие сложные структуры данных, такие как списки или объекты) в шаблон, а затем работать с этим словарем в шаблоне. Это полезно, когда вам нужно передавать несколько связанных данных, например, информацию о пользователе или продукте.  

Пример передачи словаря:  

Допустим, у вас есть словарь с информацией о пользователе, и вы хотите передать его в шаблон:
```
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def home():
    user_info = {
        'name': 'Alice',
        'age': 30,
        'email': 'alice@example.com'
    }
    return render_template('index.html', user=user_info)
```
В шаблоне `index.html` вы можете обращаться к данным словаря:
```
<!DOCTYPE html>
<html>
<head>
    <title>User Profile</title>
</head>
<body>
    <h1>User Profile</h1>
    <p>Name: {{ user.name }}</p>
    <p>Age: {{ user.age }}</p>
    <p>Email: {{ user.email }}</p>
</body>
</html>
```
Этот код отобразит:
```
User Profile
Name: Alice
Age: 30
Email: alice@example.com
```
Здесь мы передаем словарь `user_info` в шаблон под именем `user`, а затем обращаемся к значениям словаря с помощью `user.name`, `user.age` и т.д.

Работа с вложенными словарями:
Если у вас есть вложенные словари, вы можете обращаться к их значениям через несколько уровней.
```
@app.route('/')
def home():
    user_info = {
        'name': 'Alice',
        'address': {
            'street': '123 Main St',
            'city': 'Wonderland',
            'zip': '12345'
        }
    }
    return render_template('index.html', user=user_info)
```
В шаблоне `index.html`:
```
<p>Street: {{ user.address.street }}</p>
<p>City: {{ user.address.city }}</p>
<p>ZIP Code: {{ user.address.zip }}</p>
```
Это отобразит:
```
Street: 123 Main St
City: Wonderland
ZIP Code: 12345
```
## **10. Форматирование даты и времени в Jinja2**

Пример передачи даты в шаблон:  

Допустим, у вас есть объект типа `datetime`, который нужно отобразить в шаблоне в определенном формате.
```
from flask import Flask, render_template
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def home():
    current_time = datetime.now()
    return render_template('index.html', current_time=current_time)
```
В шаблоне `index.html` вы можете использовать фильтр `date`, чтобы отформатировать дату и время:
```
<!DOCTYPE html>
<html>
<head>
    <title>Current Time</title>
</head>
<body>
    <h1>Current Time: {{ current_time.strftime('%Y-%m-%d %H:%M:%S') }}</h1>
</body>
</html>
```
Этот код отобразит текущую дату и время в формате `YYYY-MM-DD HH:MM:SS`:
```
Current Time: 2025-01-19 22:30:45
```
Примеры форматов даты:  

Вот несколько примеров, как можно форматировать дату и время с помощью фильтра `date`:

* `{{ current_time.strftime('%Y-%m-%d') }}` — отображает только дату: `2025-01-19`
* `{{ current_time.strftime('%b %d, %Y') }}` — отображает дату в формате: `Jan 19, 2025`
* `{{ current_time.strftime('%A, %B %d, %Y') }}` — отображает дату в формате: `Sunday, January 19, 2025`
* `{{ current_time.strftime('%I:%M %p') }}` — отображает время в 12-часовом формате: `10:30 PM`

## **11. Работа с временем в шаблонах**

Вы можете использовать фильтры для работы с временными метками. Например, можно передать объект datetime в шаблон и отобразить его разницу с текущим временем.  

Пример расчета времени:  

Предположим, у вас есть объект `datetime`, который нужно отобразить вместе с информацией о том, сколько времени прошло с этого момента:
```
@app.route('/')
def home():
    event_time = datetime(2025, 1, 19, 14, 30)
    return render_template('index.html', event_time=event_time)
```

В шаблоне `index.html` можно вычислить разницу между текущим временем и временем события:
```
<!DOCTYPE html>
<html>
<head>
    <title>Event</title>
</head>
<body>
    <h1>Event Time: {{ event_time.strftime('%Y-%m-%d %H:%M') }}</h1>
    <p>Time until event: {{ (event_time - current_time).total_seconds() | round(0) }} seconds</p>
</body>
</html>
```

Здесь мы показываем, сколько секунд осталось до события.

## **Заключение**

Jinja2 — это мощный инструмент для создания динамических шаблонов в Flask. Он позволяет вам:

* Передавать сложные структуры данных, такие как словари, и работать с ними в шаблонах.
* Форматировать даты и время, чтобы отобразить их в нужном формате.
* Использовать различные фильтры и конструкции для динамической генерации HTML на основе переданных данных.  

Освоив основы работы с Jinja2, вы сможете создавать более гибкие и динамичные веб-приложения с Flask.

## **Задание**
Доработайте код из предыдущего проекта. 

* Задание 1: Форматирование даты и времени

- Цель: Научиться форматировать дату и время в шаблонах с использованием фильтра date.

- Описание задания:

На странице "Home" (index.html) отобразите текущую дату и время, отформатированные в формате "Сегодня: Понедельник, Январь 19, 2025, 14:30:00".

Дополнительные требования:

Используйте Python-библиотеку datetime для получения текущей даты и времени.

В шаблоне отформатируйте дату с помощью strftime.

* Задание 2: Использование циклов для отображения списка пользователей

- Цель: Научиться использовать цикл for для динамического отображения элементов списка.

- Описание задания:

На странице "О нас" (about.html) создайте список из нескольких пользователей с именами и ролями (например, список командных участников).

Отобразите этот список на странице с помощью цикла for в шаблоне.

Дополнительные требования:

Список пользователей должен быть передан в шаблон как список словарей, где каждый словарь содержит имя и роль пользователя.

Пример: 
```
    team_members = [

    {'name': 'Alice', 'role': 'Developer'},

    {'name': 'Bob', 'role': 'Designer'},

    {'name': 'Charlie', 'role': 'Project Manager'}

]
```
* Задание 3: Вложенные словари и работа с адресами

- Цель: Научиться работать с вложенными структурами данных (например, словарями).

- Описание задания:

На странице "Контакты" (contact.html) создайте и передайте в шаблон словарь с информацией об Отделе заботы о клиентах (или менеджере для связи) и адресе.

В шаблоне отобразите имя и информацию.

Дополнительные требования:

Используйте вложенные словари (например, address) и отобразите их данные (улицу, город, почтовый индекс).

# **Flask. Урок 10. Полный туториал по работе с SQLAlchemy в Flask**

## Что такое SQLAlchemy?

**SQLAlchemy – это ORM (Object Relational Mapper)**  

ORM позволяет работать с базами данных **как с объектами Python**, а не писать SQL-запросы вручную.  

**Пример:** ❌ Без ORM (обычный SQL-запрос в Python):
```
cursor.execute("INSERT INTO tasks (title) VALUES ('Buy milk')")
```
✅ С ORM (SQLAlchemy):
```
new_task = Task(title="Buy milk")
db.session.add(new_task)
db.session.commit()
```
**Это удобнее, безопаснее и читабельне**

### **Установка SQLAlchemy**
 
Сначала установим Flask и SQLAlchemy:
```
pip install flask flask-sqlalchemy
```
### **Настройка Flask и SQLAlchemy**

Создадим файл `app.py` и подключим базу SQLite:
```
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

# Указываем путь к базе данных SQLite
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Отключаем предупреждения

# Создаем объект базы данных
db = SQLAlchemy(app)
```
**💡Что здесь происходит?**

* `SQLALCHEMY_DATABASE_URI` – путь к базе **SQLite** (файл `database.db`).
* `SQLALCHEMY_TRACK_MODIFICATIONS = False` – отключает ненужные предупреждения.
* `db = SQLAlchemy(app)` – создаем объект **базы данных**.
## **Подробное описание работы с Task в SQLAlchemy (Flask ORM)**

### Описание модели Task

`В SQLAlchemy каждая таблица – это **класс** в Python.`

Добавим модель **Task** (таблица `tasks`), в которой будут:

* `id` (уникальный идентификатор)
* `title` (название задачи)
* `completed` (флаг выполнения)
Модель `Task` представляет таблицу базы данных **tasks**, которая будет содержать записи о задачах.
```
class Task(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    completed = db.Column(db.Boolean, default=False)

    def __repr__(self):
        return f"<Task {self.title}>"
```
📌 **Что здесь происходит?**
* `id = db.Column(db.Integer, primary_key=True)`
- `db.Integer` → Поле хранит целочисленные значения.
- `primary_key=True` → Значение уникально и автоматически увеличивается (ID записи).
* `title = db.Column(db.String(100), nullable=False)`
- db.String(100) → Строка до 100 символов.
- nullable=False → Поле обязательно для заполнения (не может быть NULL).
* `completed = db.Column(db.Boolean, default=False)`
- db.Boolean → Хранит True/False (статус задачи).
- default=False → Новые задачи по умолчанию невыполненные.

### **Методы SQLAlchemy для работы с Task**
 
Теперь подробно разберем **CRUD-операции** (`Create`, `Read`, `Update`, `Delete`).

 
### 📌**1. Добавление записи в базу (Create)**
```
new_task = Task(title="Buy milk")  # Создаем объект Task
db.session.add(new_task)  # Добавляем объект в сессию
db.session.commit()  # Сохраняем изменения в базе
```
**Объяснение кода:**  

1. Создаем объект класса `Task`, передавая ему title="Buy milk".
2. Добавляем объект в сессию `db.session.add(new_task)`.
3. Сохраняем изменения в базе с помощью `db.session.commit()`.  

**Результат:**  

Добавится новая строка в таблицу `tasks` с заголовком `"Buy milk"` и `completed=False`.

### 📌 **2. Получение всех записей (Read - Чтение)**
```
tasks = Task.query.all()
for task in tasks:
    print(task.id, task.title, task.completed)
```

**Объяснение кода:**  

* `Task.query.all()` → Получает все записи из таблицы.
* Проходим по **списку объектов** `tasks`, выводя их **id, title, completed`.  

**SQL-запрос в базе эквивалентен:**
```
SELECT * FROM tasks;
```
### 📌 **3. Получение записи по ID**
```
task = Task.query.get(1)
print(task.title)
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks WHERE id=1;
```
### 📌 **4. Поиск записей по условию**
```
task = Task.query.filter_by(title="Buy milk").first()
print(task.id, task.title)
```
**Объяснение кода:**  

* `Task.query.filter_by(title="Buy milk")` → Выбирает задачи, где `title="Buy milk"`.
* `.first()` → Возвращает первую найденную запись.
* Если таких записей **нет**, вернется `None`.
💡 **Аналог SQL:**
```
SELECT * FROM tasks WHERE title = 'Buy milk' LIMIT 1;
```

### 📌 **5. Обновление записи в базе (Update)**
```
task = Task.query.get(1)  # Получаем задачу с ID 1
task.title = "Buy coffee"  # Изменяем заголовок
db.session.commit()  # Сохраняем изменения
```
💡 **Аналог SQL:**
```
UPDATE tasks SET title = 'Buy coffee' WHERE id = 1;
```
📌 **Альтернативный способ через filter_by()**
```
Task.query.filter_by(title="Buy milk").update({"title": "Buy coffee"})
db.session.commit()
```
💡 **Аналог SQL:**
```
UPDATE tasks SET title = 'Buy coffee' WHERE title = 'Buy milk';
```
📌 **6. Удаление записи (Delete)**
```
task = Task.query.get(1)  # Получаем задачу по ID
db.session.delete(task)  # Удаляем
db.session.commit()  # Подтверждаем изменения
```
💡 **Аналог SQL:**
```
DELETE FROM tasks WHERE id = 1;
```
📌 **Альтернативный способ через `filter_by()`**
```
Task.query.filter_by(title="Buy coffee").delete()
db.session.commit()
```
💡 **Аналог SQL:**
```
DELETE FROM tasks WHERE title = 'Buy coffee';
```
### 📌 **Полезные функции SQLAlchemy для работы с базой данных во Flask**

SQLAlchemy предоставляет множество удобных функций и методов для взаимодействия с базой данных. Давай разберем **ключевые функции**, которые помогут **упростить и ускорить** работу с базой в Flask-приложениях.

Получение данных (READ - SELECT)  

🔹 **query.all() – Получение всех записей из таблицы**
```
tasks = Task.query.all()
for task in tasks:
    print(task.id, task.title, task.completed)
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks;
```
🔹 **query.get(id) – Получение записи по ID**
```
task = Task.query.get(2)
print(task.title)
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks WHERE id = 2;
```
❗ **Если записи нет, вернется `None` (ошибки не будет)**.

🔹 **query.get_or_404(id) – Получение записи или ошибка 404**
```
task = Task.query.get_or_404(5)  # Если ID не найден – вернет 404
```
💡 **Используется в Flask для обработки ошибок.**

🔹 **query.filter_by() – Фильтрация по одному полю**
```
task = Task.query.filter_by(title="Buy milk").first()
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks WHERE title = 'Buy milk' LIMIT 1;
```
🔹 **`query.filter()` – Фильтрация с операторами (==, !=, >, <)**
```
tasks = Task.query.filter(Task.completed == False).all()
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks WHERE completed = 0;
```
🔹 **`query.order_by()` – Сортировка**  

Сортировка по дате создания (по убыванию):
```
tasks = Task.query.order_by(Task.id.desc()).all()
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks ORDER BY id DESC;
```
🔹 **`query.limit(n)` – Ограничение количества записей**
```
tasks = Task.query.limit(3).all()  # Получить только 3 записи
```
💡 **Аналог SQL:**
```
SELECT * FROM tasks LIMIT 3;
```
Добавление данных (CREATE - INSERT)

🔹 **`db.session.add()` – Добавление новой записи**
```
new_task = Task(title="Go to the gym")
db.session.add(new_task)
db.session.commit()
```
💡 **Аналог SQL:**
```
INSERT INTO tasks (title, completed) VALUES ('Go to the gym', 0);
```
🔹 **`db.session.bulk_save_objects()` – Массовое добавление записей**
```
tasks = [
    Task(title="Buy milk"),
    Task(title="Write code"),
    Task(title="Read book")
]
db.session.bulk_save_objects(tasks)
db.session.commit()
```
💡 **Быстрее, чем `db.session.add()` для каждого объекта!**

Обновление данных (UPDATE)

🔹 **`query.get(id)` + изменение + `commit()`**
```
task = Task.query.get(1)
task.completed = True  # Меняем статус выполнения
db.session.commit()
```
💡 **Аналог SQL:**
```
UPDATE tasks SET completed = 1 WHERE id = 1;
```
🔹 **`query.filter_by().update()` – Массовое обновление записей**
```
Task.query.filter_by(completed=False).update({"completed": True})
db.session.commit()
```
💡 **Аналог SQL:**
```
UPDATE tasks SET completed = 1 WHERE completed = 0;
``` 
Удаление данных (DELETE)

🔹 **`db.session.delete()` – Удаление одной записи**
```
task = Task.query.get(3)
db.session.delete(task)
db.session.commit()
```
💡 **Аналог SQL:**
```
DELETE FROM tasks WHERE id = 3;
```
🔹 **`query.filter().delete()` – Массовое удаление записей**
```
Task.query.filter(Task.completed == True).delete()
db.session.commit()
```
💡 **Аналог SQL:**
```
DELETE FROM tasks WHERE completed = 1;
```
Подсчет записей в таблице
🔹 **`query.count()` – Подсчет количества записей**
```
count = Task.query.count()
print(f"Всего задач: {count}")
```
💡 **Аналог SQL:**
```
SELECT COUNT(*) FROM tasks;
```
🔹 **`query.filter().count()` – Подсчет записей с фильтром**
```
completed_tasks = Task.query.filter(Task.completed == True).count()
print(f"Выполненных задач: {completed_tasks}")
```
💡 **Аналог SQL:**
```
SELECT COUNT(*) FROM tasks WHERE completed = 1;
```
Проверка существования записи

🔹 **`query.exists()` – Проверка наличия записи**
```
task_exists = db.session.query(Task.id).filter_by(title="Buy milk").first() is not None
print("Задача существует!" if task_exists else "Задачи нет.")
```
💡 **Аналог SQL:**
```
SELECT 1 FROM tasks WHERE title = 'Buy milk' LIMIT 1;
```
### **Создание базы данных и таблицы**

После объявления модели нужно **создать таблицу** в базе:

Добавь этот код в `app.py` (после объявления класса `Task`):
```
with app.app_context():
    db.create_all()
```
Теперь **запусти файл**, и он создаст `database.db`

✅ Проверить базу можно через **DB Browser for SQLite** или командой:
```
sqlite3 database.db
.tables
```
### **CRUD-операции с SQLAlchemy**

Теперь реализуем **CRUD-операции**:
* **C**reate (создание)
* **R**ead (чтение)
* **U**pdate (обновление)
* **D**elete (удаление)

### 📌 **Добавление данных (Create)**

Добавим новую задачу в базу:
```
@app.route('/add/<title>')
def add_task(title):
    new_task = Task(title=title)  # Создаем объект задачи
    db.session.add(new_task)  # Добавляем в сессию
    db.session.commit()  # Сохраняем в базе
    return f"Task '{title}' added!"
```
Теперь **перейди в браузере** на:
```
http://127.0.0.1:5000/add/Buy milk
```
✅ Задача `"Buy milk"` добавится в базу.

### 📌 **Чтение данных (Read)**
 
#### **Вывести все задачи**
```
@app.route('/tasks')
def get_tasks():
    tasks = Task.query.all()  # Получаем все записи из таблицы
    return {task.id: {"title": task.title, "completed": task.completed} for task in tasks}
```
**Запроси в браузере:**
```
http://127.0.0.1:5000/tasks
```
✅ Получишь JSON со всеми задачами.

### 📌 **Обновление данных (Update)**

Изменим заголовок задачи:
```
@app.route('/update/<int:id>/<new_title>')
def update_task(id, new_title):
    task = Task.query.get_or_404(id)  # Получаем задачу по ID
    task.title = new_title  # Меняем заголовок
    db.session.commit()  # Сохраняем изменения
    return f"Task {id} updated to '{new_title}'!"
```
**Измени задачу по ID:**
```
http://127.0.0.1:5000/update/1/Buy coffee
```
✅ Задача `"Buy milk"` теперь называется `"Buy coffee"`.

### 📌 **Удаление данных (Delete)**

Удалим задачу по ID:
```
@app.route('/delete/<int:id>')
def delete_task(id):
    task = Task.query.get_or_404(id)  # Найти задачу
    db.session.delete(task)  # Удалить из базы
    db.session.commit()  # Сохранить изменения
    return f"Task {id} deleted!"
```
**Удаление в браузере:**
```
http://127.0.0.1:5000/delete/1
```
✅ Задача с ID `1` удалится.

# **Flask. Урок 11. Менеджер задач (To-Do List)**

В этом уроке мы создаем простое веб-приложение **To-Do List** — менеджер задач, который позволяет пользователям:

- ✅ **Добавлять новые задачи** через веб-форму.
- ✅ **Просматривать список задач**, хранящихся в базе данных.
- ✅ **Редактировать существующие задачи**.
- ✅ **Удалять задачи** по нажатию кнопки.  

Приложение использует **Flask** для работы с веб-интерфейсом, **SQLite** в качестве базы данных и **SQLAlchemy** как ORM для управления данными.

## Как это будет работать?
 
1️⃣ **Пользователь открывает главную страницу (/tasks)**  

На этой странице отображается список всех задач, добавленных в базу данных.  

Для каждой задачи есть две кнопки: **Редактировать** и **Удалить**.

<img src="{{ url_for('static', filename='images/16.png') }}" alt="Logo">

2️⃣ **Пользователь нажимает кнопку "Добавить задачу"**  

Открывается страница с формой (/add), где он вводит название новой задачи и отправляет форму.  

После отправки данные записываются в базу, и задача появляется в общем списке.  

3️⃣ **Пользователь может редактировать задачу**  

При нажатии на кнопку Редактировать (/edit/) открывается форма с текущим названием задачи.  

Пользователь может изменить название и сохранить изменения.

4️⃣ **Пользователь может удалить задачу**

При нажатии на кнопку Удалить (/delete/) задача удаляется из базы.

<img src="{{ url_for('static', filename='images/17.png') }}" alt="Logo">

<img src="{{ url_for('static', filename='images/18.png') }}" alt="Logo">

## **1. Создай структуру проекта**

Перед началом работы создай следующую структуру:
```
project/
├── app.py            # Основной файл приложения
├── templates/        # HTML-шаблоны
│   ├── tasks.html    # Главная страница (список задач)
│   ├── add_task.html # Форма добавления задачи
│   ├── edit_task.html # Форма редактирования задачи
└── database.db       # База данных (создается автоматически)
```
## **2. Код `app.py` — Основное приложение**

Открываем `app.py` и вставляем код:
```
from flask import Flask, render_template, request, redirect, url_for
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

# Настройка базы данных SQLite
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Инициализация базы данных
db = SQLAlchemy(app)

# Модель задачи (таблица Task)
class Task(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)

    def __repr__(self):
        return f"<Task {self.title}>"

# Создаем таблицу в базе данных
with app.app_context():
    db.create_all()

### 📌 CRUD-МАРШРУТЫ

# 📌 Главная страница: список задач
@app.route('/')
@app.route('/tasks')
def get_tasks():
    tasks = Task.query.all()  # Получаем все задачи из базы
    return render_template('tasks.html', tasks=tasks)

# 📌 Добавление новой задачи
@app.route('/add', methods=['GET', 'POST'])
def add_task():
    if request.method == 'POST':
        title = request.form['title']
        if title.strip():  # Проверяем, что строка не пустая
            new_task = Task(title=title)
            db.session.add(new_task)
            db.session.commit()
        return redirect(url_for('get_tasks'))
    return render_template('add_task.html')

# 📌 Редактирование задачи
@app.route('/edit/<int:id>', methods=['GET', 'POST'])
def edit_task(id):
    task = Task.query.get_or_404(id)  # Получаем задачу по ID
    if request.method == 'POST':
        new_title = request.form['title']
        if new_title.strip():
            task.title = new_title
            db.session.commit()
        return redirect(url_for('get_tasks'))
    return render_template('edit_task.html', task=task)

# 📌 Удаление задачи
@app.route('/delete/<int:id>')
def delete_task(id):
    task = Task.query.get_or_404(id)  # Получаем задачу по ID
    db.session.delete(task)  # Удаляем из базы
    db.session.commit()  # Подтверждаем изменения
    return redirect(url_for('get_tasks'))

# Запуск сервера
if __name__ == "__main__":
    app.run(debug=True)
```
 
## **3. Шаблоны HTML (в папке `templates/`)**

Дальше в шаблонах будет использоваться Bootstrap.  

Bootstrap – это популярный CSS-фреймворк для быстрой и удобной разработки адаптивных сайтов и веб-приложений. Он позволяет быстро стилизовать сайт без глубокого знания CSS, включает готовые компоненты (кнопки, формы, карточки, модальные окна), делает сайт адаптивным (корректно отображается на мобильных и десктопах).  

Вы можете написать свою верстку для проекта, а если есть желание поглубже разобраться в этой теме, то почитать про Bootstrap:  

👉 Официальный сайт: https://getbootstrap.com или сразу https://bootstrap-4.ru/docs/5.3/getting-started/introduction/

Ютуб:  


📌 **Шаблон `tasks.html` — Главная страница (список задач)**  

Создай файл `templates/tasks.html` и вставь этот код:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task List</title>
    <!-- Подключаем Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">

    <div class="container mt-5">
        <h1 class="text-center">Task List</h1>
        
        <div class="card shadow p-3">
            <ul class="list-group">
                {% for task in tasks %}
                <li class="list-group-item d-flex justify-content-between align-items-center">
                    {{ task.title }}
                    <div>
                        <a href="{{ url_for('edit_task', id=task.id) }}" class="btn btn-sm btn-warning">Edit</a>
                        <a href="{{ url_for('delete_task', id=task.id) }}" class="btn btn-sm btn-danger" onclick="return confirm('Are you sure?')">Delete</a>
                    </div>
                </li>
                {% endfor %}
            </ul>
        </div>

        <div class="text-center mt-4">
            <a href="{{ url_for('add_task') }}" class="btn btn-success">Add New Task</a>
        </div>
    </div>

</body>
</html>
```

📌 `add_task.html` — **Форма добавления задачи**  

Создай файл `templates/add_task.html`:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add Task</title>
    <!-- Подключаем Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">

    <div class="container mt-5">
        <h1 class="text-center">Add a New Task</h1>

        <div class="card shadow p-4">
            <form method="POST">
                <div class="mb-3">
                    <label for="title" class="form-label">Task Title:</label>
                    <input type="text" id="title" name="title" class="form-control" required>
                </div>
                <button type="submit" class="btn btn-primary w-100">Add Task</button>
            </form>
        </div>

        <div class="text-center mt-4">
            <a href="{{ url_for('get_tasks') }}" class="btn btn-secondary">Back to Task List</a>
        </div>
    </div>

</body>
</html>
```
📌 **`edit_task.html` — Форма редактирования задачи**  

Создай файл `templates/edit_task.html`:
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Task</title>
    <!-- Подключаем Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">

    <div class="container mt-5">
        <h1 class="text-center">Edit Task</h1>

        <div class="card shadow p-4">
            <form method="POST">
                <div class="mb-3">
                    <label for="title" class="form-label">Task Title:</label>
                    <input type="text" id="title" name="title" class="form-control" value="{{ task.title }}" required>
                </div>
                <button type="submit" class="btn btn-primary w-100">Update Task</button>
            </form>
        </div>

        <div class="text-center mt-4">
            <a href="{{ url_for('get_tasks') }}" class="btn btn-secondary">Back to Task List</a>
        </div>
    </div>

</body>
</html>
```
### 📌 **Как открыть и посмотреть базу данных SQLite из проекта?**
Файл базы данных `database.db` хранит все задачи, но его нельзя просто открыть как текстовый файл. Для просмотра данных SQLite есть несколько способов:

### 1️⃣ **Открыть базу через SQLite Viewer Online (без установки)**

Если у тебя нет специальных программ, можно просто открыть базу в браузере:

1. Перейди на сайт **SQLite Viewer Online**.
2. Нажми **"Choose File"** и выбери `database.db` из проекта.
3. Таблицы и данные загрузятся → можно смотреть и экспортировать.  

✅ **Плюсы:** Быстро, без установки.  

❌ **Минусы:** Только просмотр (без редактирования).

### 2️⃣ **Использовать DB Browser for SQLite (GUI-программа)**  

Этот способ удобен для работы с базой данных в графическом интерфейсе.  

### 🔹 Установка DB Browser for SQLite
* **Windows/macOS/Linux:** Скачать тут https://sqlitebrowser.org/
### 🔹 Как открыть базу данных?
1. Открой **DB Browser for SQLite**.
2. Нажми **"Open Database"** и выбери файл database.db.
3. Переключись на вкладку **"Browse Data"**, выбери таблицу **Task**.
4. Теперь ты можешь **просматривать**, **редактировать** и **удалять данные**.  

✅ **Плюсы:** Полноценная работа с БД (добавление, изменение, удаление).  

❌ **Минусы:** Нужно скачать и установить программу.  

### 3️⃣ Просмотр через командную строку (терминал)

Если ты работаешь в Linux, macOS или Windows с WSL, можешь использовать встроенную командную строку SQLite.

### 🔹 Открыть базу в терминале
1. Перейди в папку проекта:
```
cd path/to/project
```
2. Открой SQLite:
```
sqlite3 database.db
```
3. Посмотреть список таблиц:
```
.tables
```
4. Просмотреть содержимое таблицы Task:
```
SELECT * FROM Task;
```
✅ **Плюсы:** Быстро, не требует GUI.  

❌ **Минусы:** Нужны базовые SQL-команды.

# **Flask. Агентство тайных агентов**
##### **Предыстория:**

Ты – разработчик в **секретном агентстве**, которое управляет сотнями **тайных агентов по всему миру**. Но есть проблема: **все досье ведутся на бумаге**! 📜😱

##### **Задача:**
Тебе поручено создать **секретную цифровую базу данных агентов**! Это приложение поможет шефу разведки легко **добавлять, редактировать и находить агентов** по их кодовым именам.

### 🎯 **Функционал системы:**

📌 1. Панель управления агентами (/) → Список всех агентов.  

📌 2. Добавление нового агента (/add) → Заполни анкету для нового шпиона.  

📌 3. Просмотр досье агента (/agent/<id>) → Все данные о конкретном агенте.  

📌 4. Редактирование данных агента (/edit/<id>) → Обновление информации.  

📌 5. Удаление агента из базы (/delete/<id>) → Уничтожить досье!  

📌 6. Поиск агентов по кодовому имени (доп. задание).  
 
### 📂 **1. Структура базы данных**

Каждый агент должен иметь **уникальное досье**, содержащее:
✅ **ID** (номер досье)  

✅ **Кодовое имя** (никнейм в разведке, например "Black Widow")  

✅ **Контактный номер** (для экстренной связи)  

✅ **Email** (для шифрованных сообщений)  

✅ **Уровень доступа** (например, "Секретно", "Совершенно секретно")

### 📌 2. **Дополнительные фишки (выбрать минимум 2 для реализации)**
🔹 **Фильтр агентов по уровню доступа**.
🔹 **Кнопка "Отправить срочное сообщение" (почта агента)**. - можно сделать имитацию 
🔹 **Темная тема (для работы ночью)**.
🔹 **Генерация случайных кодовых имен** (например, "Shadow Fox").
🔹 **Секретный режим** – удаление всех данных в один клик.

### **Задание**
```
Приложите код решения или ссылку на гитхаб проекта
```